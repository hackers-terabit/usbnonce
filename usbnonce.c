/*  USBnonce 0.1a
 * 
 * 	This small C program is suppose to enable the usage of
 *  removable storage drives as a factor of authentication.
 * 
 *  At start-up it will await for a new drive to be plugged in.
 *  When a new drive with a usable partition and a file system matching
 *  the default of ext4 (or user specfied via -f flag) is detected,
 * 	it will place bytes generated by the system's random number generator 
 *  in a file called '.nonce' at the root of the first detected
 *  partition and file system on the drive.
 * 
 *  At this point,it is "synced" awaiting the removal of the drive.
 *  
 *  When the drive is removed it becomes 'active' and notifies 
 *  anyone listening to 'LOCK',when the removable drive is re-inserted,
 *  it should check for the '.nonce' bytes to see if they match the bytes
 *  stored when it became 'synced'. if they match a notification to unlock
 *  is sent and a new 'sync' is attempted.
 * 
 *  The goal is simply to notify any listeners that a removable drive 
 *  with the unique and random nonce bytes has been synchronized,removed/active and
 *  when a new drive is inserted to tell the same listeners if a valid nonce was found.
 * 
 *  I wanted to do things like lock screens(on a VM host and all it's guests),
 *  close particular encryted disks,suspend or kill processes and stop/start services
 *  when the USB drive in my possession is physhically plugged into the system/network.
 * 
 * 	If you plan on using this, be aware of some security considerations:
 * 		- this isn't meant to be your first or last line of defense when it comes to
 * 		  authentication or any form of security.
 * 		
 *      - It is simply a very cheap means of using 'posession' of a removable drive
 * 		  to make decisions and take actions. 
 * 		- It is assumed(VERY IMPORTANT) that everyone that is able to send traffic to the 
 * 		  'multi cast'(or set via -d) IP address and port is trusted otherwise they call tell all listeners
 * 		  to lock or unlock at will which makes this whole thing pointless 
 * 		  (when in doubt use 127.0.0.1 and drop the udp port on ingress points to the trusted network)
 * 		
 * 		- If you can't ensure physhical posession by you and only after this application is 'active'
 * 		  it is of no use to you.
 * 		
 * 		- Lastly, udev notifications aren't all that reliable,so plugging in/out a few times might be needed.
 * 		
 * 
 * ********************************************************************************************/
#define _GNU_SOURCE

#define NSZ 512 


#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <fcntl.h>
#include <poll.h>
#include <libudev.h>
#include <string.h>
#include <ctype.h>
#include <sys/mount.h>
#include <sys/stat.h>
#include <errno.h>
#include <linux/random.h>
#include <linux/stat.h>
#include <seccomp.h>
#include <sys/ioctl.h>
#include <sys/types.h>
#include <sys/syscall.h>

#include <sys/socket.h>
#include <arpa/inet.h>
#include <linux/in.h>

struct shared{
	char *version;
	char *mountpath; 		/* temporary mount path, should be unmouted after nonce is written */
	char *fstype;			/* the fs of the removable drive */
	char *multicast_addr; 	/* the IPv4 multicast address to send UDP event notification to */
	uint16_t port;  		/* the UDP destination port for notification messages */
	
	char * NOTREADY;		/* hasn't finished starting up yet */
	char * LOCKREADY; 		/* nonce is synced, awaiting device removal to lock/activate */
	char * LOCK;			/* device removed after LOCKREADY,system is good to lock */
	char * UNLOCKREADY;		/* good nonce read on device plug in while system was in an active/locked state */
	char * UNLOCKFAIL; 		/* failed to read a good nonce while in sync, not a bad thing unless system was locked/active */
} g;

struct noncesync{
	
	uint8_t mountme; 	/* data in here is ready for mount */
	uint8_t gone;		/* drive and/or partition removed */
	uint8_t sync;		/* nonce written */
	uint8_t active; 	/* drive removed after a good sync */
	uint8_t nonce[NSZ]; /* should hold random bytes */
	
	char partition_device[32];   	/* usable/writable partition like 'sda1' */
	char parent_device[32];			/* this would be the device the partition above lies on,as in 'sda' */
	char partition_devpath[256];  	/* sysfs path  for these last two */
	char parent_devpath[256];
	
	/* libudev handles */
	struct udev *u;
	struct udev_monitor *um;
	struct udev_device *ud;
	struct udev_enumerate *ue;
	struct udev_queue *uq;
	int ufd;
};

struct mcast{
	int sk;
	struct sockaddr_in d;
};

int poprand(char *buf,int sz){
	int ret=0;
	FILE *rf;
	do{
		rf=fopen("/dev/urandom","r");
		if(rf==NULL){
			perror("Unable to open /dev/random\n");
			return -1;
		}
		
		ret= fread(buf,1,sz,rf);//linker errors on 4.4.8 :( --->getrandom((void *) buf,NSZ,GRND_RANDOM);
		if(ret==-1){
			perror("poprandom error");
			return -1;
		}
		if(ret<NSZ){
			printf("Not enough random bytes, trying again...");
		}else{
			return 0;
		}
	usleep(500);	
	}while(ret<NSZ);
	
	return -1;	
}

int init_udev(struct noncesync *n){
	n->u=udev_new();
	n->ue=udev_enumerate_new(n->u);
	n->uq=udev_queue_new(n->u);
	
	if(udev_enumerate_add_match_subsystem(n->ue,"block")<0){
		perror("udev_enumerate_add_match_subsystem error.");
	}
	
	
	if(!n->u){
		perror("Error getting a udev handle.");
		return -1;
	}
	
	n->um=udev_monitor_new_from_netlink(n->u,"udev");
	if(n->um==NULL){
		perror("udev_monitor_new_from_netlink error");
		return -1;
	}
	if(udev_monitor_filter_add_match_subsystem_devtype(n->um,"block",NULL)<0){
		perror("udev_monitor_filter_add_match_subsystem_devtype error");
		return -1;
	}
	if(udev_monitor_enable_receiving(n->um)<0){
		perror("udev_monitor_enable_receiving error.");
		return -1;
	}
	n->ufd=udev_monitor_get_fd(n->um);
	

return 0;	
}
void monitor(struct noncesync *n){

	int ret;
	struct pollfd pfd;
	char sysname[32],devpath[256];
	char action[32],removable[10],readonly[10],partition[10];
	
	n->mountme=0;
	
	
	

	pfd.fd=n->ufd;
	if(pfd.fd<1){
		perror("udev_monitor_get_fd error.");
		return ;
	}
	pfd.events=POLLIN;


	while(!udev_queue_get_queue_is_empty(n->uq)){
		ret=poll(&pfd,1,-1);
		if (ret<0){
			perror("Poll error.");
		}else{
			n->ud=udev_monitor_receive_device(n->um);
			if(n->ud==NULL){
				perror("udev_monitor_receive_device error.");
				return;
			}
			
			
			
			snprintf(sysname,32,"%s",udev_device_get_sysname(n->ud));
			snprintf(devpath,255,"%s",udev_device_get_devpath(n->ud));
			snprintf(action,30,"%s",udev_device_get_action(n->ud));
			snprintf(removable,5,"%s",udev_device_get_sysattr_value(n->ud,"removable"));
			snprintf(readonly,5,"%s",udev_device_get_sysattr_value(n->ud,"ro"));
			snprintf(partition,5,"%s",udev_device_get_sysattr_value(n->ud,"partition"));
			
			if(strncmp(action,"add",3)==0 &&  strncmp(partition,"1",1)!=0 && strncmp(removable,"1",1)==0 && strncmp(readonly,"0",1)==0){ //parent block , like /dev/sda
					printf("---------------------------------\n");
					printf("New removable drive added on /dev/%s\n",sysname);
					printf("Dev path: %s\n",devpath);
					printf("Action: %s\n",action);
					printf("Readonly: %s\n",readonly);
					printf("Removable: %s\n",removable);
					
					snprintf(n->parent_device,32,"%s",sysname);
					snprintf(n->parent_devpath,256,"%s",devpath);		
					n->gone=0;
					return;
			}else if(strncmp(action,"add",3)==0  && strncmp("1",partition,1)==0 ){ //child partition like /dev/sda1
				struct udev_device *parent=udev_device_get_parent(n->ud);
				
				if (parent==NULL)return;
				udev_enumerate_scan_devices(n->ue);
				if(strncmp(n->parent_devpath,udev_device_get_devpath(parent),32)==0){
					printf("---------------------------------\n");
					printf("New partition added on /dev/%s\n",sysname);
					printf("Dev path: %s\n",devpath);
					printf("Action: %s\n",action);
					printf("Readonly: %s\n",readonly);
					printf("Partition: %s\n",partition);
					printf("Parent device: /dev/%s\n",udev_device_get_sysname(parent));
					snprintf(n->partition_device,32,"%s",sysname);
					snprintf(n->partition_devpath,256,"%s",devpath);
					n->mountme=1;
					n->gone=0;
					return;
				}	
	
			}else if(strncmp(action,"remove",6)==0){
				udev_enumerate_scan_devices(n->ue);
				printf("removed %s\n",sysname);
				struct udev_device *parent=udev_device_get_parent(n->ud);
				if((!n->gone )&& ((strncmp(udev_device_get_sysname(parent),n->parent_device,32)==0 && strncmp(udev_device_get_devpath(parent),n->parent_devpath,255)==0 ) ||
									(strncmp(sysname,n->partition_device,32)==0 && strncmp(devpath,n->partition_devpath,255)==0 ) ||
									(strncmp(sysname,n->parent_device,32)==0 && strncmp(devpath,n->parent_devpath,255)==0 )
									)){
					printf("---------------------------------\n");
					printf("Previously detected device removed /dev/%s\n",sysname);
					printf("Parent device: /dev/%s\n",n->parent_device);
					printf("Parent device path: %s\n",n->parent_devpath);
					printf("Partition device: /dev/%s\n",n->partition_device);
					printf("Partition device path: %s\n",n->parent_devpath);
					printf("Action: %s\n",action);
					n->gone=1;
					n->mountme=0;
					return;
			}else{
					
					printf("---------------------------------\n");
					printf("[%i] Uncaught device removal:/dev/%s ,parent %s,child\n",n->gone,sysname,udev_device_get_sysnum(parent));
					printf("device removed /dev/%s\n",sysname);
					printf("device removed path %s\n",devpath);
					printf("Action: %s\n",action);
					printf("In sync for active device:/dev/%s\n",n->parent_device);
					printf("In sync for partition:/dev/%s\n",n->partition_device);
			}
			}
		}
	}
}

int multicast(const char*buf,int sz,struct mcast* mc){
	int ret;
	if(sz>256)
		sz=256;
	if(sz<0)
		sz=0;
		
	unsigned char sendbuf[256];
	memset(sendbuf,0,256);
	memcpy(sendbuf,buf,sz);
	ret=sendto(mc->sk,sendbuf,sz,0,(struct sockaddr *) &mc->d, sizeof(struct sockaddr_in));
	if(ret <0){
		perror("sendto error");
		return -1;
	}else{
		return ret;
	}
	return -1;
}

void drop_privs () {
     int ret = 0;
     /*if( setgid (65533) ||setuid (65534) ){  :( mount(2) won't work if I do this.
		perror("Failure to drop priviledge using setgid/setuid\r\n");
		exit(1);
		}*/
		
     scmp_filter_ctx ctx;
     ctx = seccomp_init (SCMP_ACT_ALLOW);

	ret += seccomp_rule_add (ctx, SCMP_ACT_ALLOW, SCMP_SYS (arch_prctl), 0);
	ret += seccomp_rule_add (ctx, SCMP_ACT_ALLOW, SCMP_SYS (bind), 0);
	ret += seccomp_rule_add (ctx, SCMP_ACT_ALLOW, SCMP_SYS (brk), 0);
	ret += seccomp_rule_add (ctx, SCMP_ACT_ALLOW, SCMP_SYS (close), 0);
	ret += seccomp_rule_add (ctx, SCMP_ACT_ALLOW, SCMP_SYS (execve), 0);
	ret += seccomp_rule_add (ctx, SCMP_ACT_ALLOW, SCMP_SYS (fstat), 0);
	ret += seccomp_rule_add (ctx, SCMP_ACT_ALLOW, SCMP_SYS (getdents), 0);
	ret += seccomp_rule_add (ctx, SCMP_ACT_ALLOW, SCMP_SYS (getrandom), 0);
	ret += seccomp_rule_add (ctx, SCMP_ACT_ALLOW, SCMP_SYS (getrlimit), 0);
	ret += seccomp_rule_add (ctx, SCMP_ACT_ALLOW, SCMP_SYS (getsockname), 0);
	ret += seccomp_rule_add (ctx, SCMP_ACT_ALLOW, SCMP_SYS (gettid), 0);
	ret += seccomp_rule_add (ctx, SCMP_ACT_ALLOW, SCMP_SYS (lseek), 0);
	ret += seccomp_rule_add (ctx, SCMP_ACT_ALLOW, SCMP_SYS (lstat), 0);
	ret += seccomp_rule_add (ctx, SCMP_ACT_ALLOW, SCMP_SYS (mkdir), 0);
	ret += seccomp_rule_add (ctx, SCMP_ACT_ALLOW, SCMP_SYS (mmap), 0);
	ret += seccomp_rule_add (ctx, SCMP_ACT_ALLOW, SCMP_SYS (mount), 0);
	ret += seccomp_rule_add (ctx, SCMP_ACT_ALLOW, SCMP_SYS (mprotect), 0);
	ret += seccomp_rule_add (ctx, SCMP_ACT_ALLOW, SCMP_SYS (munmap), 0);
	ret += seccomp_rule_add (ctx, SCMP_ACT_ALLOW, SCMP_SYS (open), 0);
	ret += seccomp_rule_add (ctx, SCMP_ACT_ALLOW, SCMP_SYS (poll), 0);
	ret += seccomp_rule_add (ctx, SCMP_ACT_ALLOW, SCMP_SYS (read), 0);
	ret += seccomp_rule_add (ctx, SCMP_ACT_ALLOW, SCMP_SYS (readlinkat), 0);
	ret += seccomp_rule_add (ctx, SCMP_ACT_ALLOW, SCMP_SYS (recvmsg), 0);
	ret += seccomp_rule_add (ctx, SCMP_ACT_ALLOW, SCMP_SYS (rt_sigaction), 0);
	ret += seccomp_rule_add (ctx, SCMP_ACT_ALLOW, SCMP_SYS (rt_sigprocmask), 0);
	ret += seccomp_rule_add (ctx, SCMP_ACT_ALLOW, SCMP_SYS (sendto), 0);
	ret += seccomp_rule_add (ctx, SCMP_ACT_ALLOW, SCMP_SYS (set_robust_list), 0);
	ret += seccomp_rule_add (ctx, SCMP_ACT_ALLOW, SCMP_SYS (set_tid_address), 0);
	ret += seccomp_rule_add (ctx, SCMP_ACT_ALLOW, SCMP_SYS (setsockopt), 0);
	ret += seccomp_rule_add (ctx, SCMP_ACT_ALLOW, SCMP_SYS (socket), 0);
	ret += seccomp_rule_add (ctx, SCMP_ACT_ALLOW, SCMP_SYS (umount2), 0);
	ret += seccomp_rule_add (ctx, SCMP_ACT_ALLOW, SCMP_SYS (write), 0);
	ret += seccomp_rule_add (ctx, SCMP_ACT_ALLOW, SCMP_SYS (ioctl), 1, SCMP_A1 (SCMP_CMP_EQ, (int) TCGETS));
	
	ret += seccomp_rule_add (ctx, SCMP_ACT_ALLOW, SCMP_SYS (seccomp), 0);
     ret = seccomp_load (ctx);
     if (ret < 0){
          perror("Error loading SECCOMP!");
          exit(1);
	  }
     seccomp_release (ctx);

}


void usage(){
		printf("%s Usage:\n"
				"\tusbnonce [-mfdph]\n"
				"\t-m <mountpoint>\t set the filesystem mount point that will be used to temporarily mount the removable drive.\n"
				"\t-f <filesystem>\t set the filesystem the removable drive is expected to use.\n"
				"\t-d <ipv4addr>\t set the destination IPv4 address for UDP notifications\n"
				"\t-p <port>\t set the destination port number for UDP notifications.\n"
				"\t-h \t Display this usage info.\n"
				,g.version);
				exit(1);
}

int main(int argc,char **argv){
	
	/*setup shared variables/globals..*/
	g.version="USBnonce 0.1a";
	g.mountpath="/tmp/usbnonce";
	g.fstype="ext4";		
	g.multicast_addr="127.0.0.1";
	g.port=56789; 
	
	g.NOTREADY="NOTREADY";	
	g.LOCKREADY="READYLOCK"; 	
	g.UNLOCKREADY="UNLOCKREADY";	
	g.UNLOCKFAIL="FAILUNLOCK"; 
	g.LOCK="LOCK";
	
	
	
	struct noncesync n;
	char nonce[NSZ];

	setvbuf(stdout,NULL,_IONBF,0);
	memset(&n,0,sizeof(n));
	
	struct mcast mc;
	memset(&mc,0,sizeof(struct mcast));
	
	int c=0;
	
	while((c=getopt(argc,argv,"m:f:d:p:h"))!=-1){
			switch(c){
				case 'm':
					g.mountpath=optarg;
					break;
				case 'f':
					g.fstype=optarg;
					break;
				case 'd':
					g.multicast_addr=optarg;
					break;
				case 'p':
					g.port=atoi(optarg);
					break;
				case 'h':
				default:
					usage();
				}
	}
	
	
	
	if(init_udev(&n)!=0){
		printf("Udev init error!");
		return 1;
		
	}
	
	mc.sk=socket(AF_INET,SOCK_DGRAM,IPPROTO_UDP);
	if(mc.sk<1){
		perror("Socket creation error,exiting.");
		return -1;
		}
		

	
	mc.d.sin_family=AF_INET;
	htonl(inet_aton(g.multicast_addr,&mc.d.sin_addr));
	mc.d.sin_port=htons(g.port);
	
		
	
	drop_privs();
	
	multicast(g.NOTREADY,strlen(g.NOTREADY),&mc);
	printf("Socket init done.\n");
	
	while(1){
		usleep(100);
		monitor(&n);
		//usleep(10000);
		if(n.mountme){
			char pdev[256];
			snprintf(pdev,255,"/dev/%s",n.partition_device);
			if(mkdir(g.mountpath,0644)!=0 && errno!=EEXIST){
				perror("Warning,mkdir error,mount might fail.");
			}
			if((mount(pdev,g.mountpath,g.fstype,MS_MGC_VAL,NULL))!=0){
				printf("Mount params: %s %s %s ...\n",pdev,g.mountpath,g.fstype);
				fflush(stdout);
				perror("Error mounting the newly detected device");
				
				continue;
			}else{
				printf("Mount successful %s ---> %s\n",pdev,g.mountpath);
				memset(nonce,0,NSZ);
				if(poprand(&nonce[0],NSZ)==0){
					char nfile[256];
					snprintf(nfile,256,"%s/.nonce",g.mountpath);
					FILE *nf=fopen(nfile,"rw+");
					if(nf==NULL){
						perror("Error opening nonce file.");
						printf("File:%s\n",nfile);
						if(n.sync && n.active){
							printf("UNLOCKFAIL \n");
							multicast(g.UNLOCKFAIL,strlen(g.UNLOCKFAIL),&mc);
						
					}
					umount(g.mountpath);
						continue;
					}else if(!n.sync){
						if(fwrite(nonce,1,NSZ,nf)!=NSZ){
							perror("Error writing out nonce");
							fclose(nf);
							umount(g.mountpath);
							continue;
					}else{
						memset(n.nonce,0,NSZ);
						memcpy(n.nonce,nonce,NSZ);
						n.sync=1;
						printf("Nonce written,synced.\n");
						multicast(g.LOCKREADY,strlen(g.LOCKREADY),&mc);
						fflush(nf);
						fclose(nf);
						umount(g.mountpath);
					}
					
				}else if(n.sync==1){
					int ret=fread(nonce,1,NSZ,nf);
					if( ret!= NSZ && n.active){
						perror("error reading nonce from usb, True negative!");
						printf("nonce read %i bytes\n",ret);
						
						multicast(g.UNLOCKFAIL,strlen(g.UNLOCKFAIL),&mc);
						
						fclose(nf);
						umount(g.mountpath);
						
						continue;
					}else{
						if(memcmp(nonce,n.nonce,NSZ)==0){ // This is where we authenticate,no other logic should result in a True positive(successful authentication).
							printf("True positive,unlock here!\n");
							
							multicast(g.UNLOCKREADY,strlen(g.UNLOCKREADY),&mc);
							n.active=0;
							n.sync=0;
							memset(n.nonce,0,NSZ);
							memset(nonce,0,NSZ);
							if(fseek(nf,0,SEEK_SET)!=0){
								perror("Warning! fseek on nonce failed post successful authentication,next nonce might fail.");
							}
							if(poprand(&nonce[0],NSZ)==0){
								if(fwrite(nonce,1,NSZ,nf)!=NSZ){
									perror("Error writing out nonce at post successful authentication.");
									umount(g.mountpath);
									fclose(nf);
									continue;
								}else{
									memcpy(n.nonce,nonce,NSZ);
									n.sync=1;
									printf("Nonce written,nonce synced\n");
									multicast(g.LOCKREADY,strlen(g.LOCKREADY),&mc);
									fflush(nf);
									fclose(nf);
								}	
							}else{
								printf("RNG error post successful authentication.\n");
								}
						}else{
							printf("True negative!\n");
							multicast(g.UNLOCKFAIL,strlen(g.UNLOCKFAIL),&mc);
						}
					}
					
					
				}
			}else{
				printf("RNG error.\n");
				umount(g.mountpath);
				continue;
				}
			umount(g.mountpath);
			}
		}else if(n.gone){
			
		if(n.sync && !(n.active)){
			printf("LOCK\n");
			n.active=1;
			multicast(g.LOCK,strlen(g.LOCK),&mc);
				}
		}	
	}
	close(mc.sk);	
return 0;
}

