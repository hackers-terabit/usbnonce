/*  USBnonce 0.1a
 * 
 * 	This small C program is suppose to enable the usage of
 *  removable storage drives as a factor of authentication.
 * 
 *  At start-up it will await for a new drive to be plugged in.
 *  When a new drive with a usable partition and a file system matching
 *  the default of ext4 (or user specfied via -f flag) is detected,
 * 	it will place bytes generated by the system's random number generator 
 *  in a file called '.nonce' at the root of the first detected
 *  partition and file system on the drive.
 * 
 *  At this point,it is "synced" awaiting the removal of the drive.
 *  
 *  When the drive is removed it becomes 'active' and notifies 
 *  anyone listening to 'LOCK',when the removable drive is re-inserted,
 *  it should check for the '.nonce' bytes to see if they match the bytes
 *  stored when it became 'synced'. if they match a notification to unlock
 *  is sent and a new 'sync' is attempted.
 * 
 *  The goal is simply to notify any listeners that a removable drive 
 *  with the unique and random nonce bytes has been synchronized,removed/active and
 *  when a new drive is inserted to tell the same listeners if a valid nonce was found.
 * 
 *  I wanted to do things like lock screens(on a VM host and all it's guests),
 *  close particular encryted disks,suspend or kill processes and stop/start services
 *  when the USB drive in my possession is physhically plugged into the system/network.
 * 
 * 	If you plan on using this, be aware of some security considerations:
 * 		- this isn't meant to be your first or last line of defense when it comes to
 * 		  authentication or any form of security.
 * 		
 *      - It is simply a very cheap means of using 'posession' of a removable drive
 * 		  to make decisions and take actions. 
 * 		- It is assumed(VERY IMPORTANT) that everyone that is able to send traffic to the 
 * 		  'multi cast'(or set via -d) IP address and port is trusted otherwise they call tell all listeners
 * 		  to lock or unlock at will which makes this whole thing pointless 
 * 		  (when in doubt use 127.0.0.1 and drop the udp port on ingress points to the trusted network)
 * 		
 * 		- If you can't ensure physhical posession by you and only after this application is 'active'
 * 		  it is of no use to you.
 * 		
 * 		- Lastly, udev notifications aren't all that reliable,so plugging in/out a few times might be needed.
 * 		
 * 
 * ********************************************************************************************/
#define _GNU_SOURCE

#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <fcntl.h>
#include <poll.h>
#include <libudev.h>
#include <string.h>
#include <ctype.h>
#include <sys/mount.h>
#include <sys/stat.h>
#include <errno.h>
#include <linux/random.h>
#include <linux/stat.h>
#include <seccomp.h>
#include <sys/ioctl.h>
#include <sys/types.h>
#include <sys/syscall.h>
#include <syslog.h>
#include <signal.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <linux/in.h>

struct shared{
	char *version;
	char *mountpath; 		/* temporary mount path, should be unmouted after nonce is written */
	char *fstype;			/* the fs of the removable drive */
	char *multicast_addr; 	/* the IPv4 multicast address to send UDP event notification to */
	char devp[12];			/* typically /dev , the path to the devfs mount path */

	char * NOTREADY;		/* hasn't finished starting up yet */
	char * LOCKREADY; 		/* nonce is synced, awaiting device removal to lock/activate */
	char * LOCK;			/* device removed after LOCKREADY,system is good to lock */
	char * UNLOCKREADY;		/* good nonce read on device plug in while system was in an active/locked state */
	char * UNLOCKFAIL; 		/* failed to read a good nonce while in sync, not a bad thing unless system was locked/active */
	
	uint16_t port;  		/* the UDP destination port for notification messages */
	uint32_t nsz;			/* byte count of the random bytes to be used as a 'nonce' */
	uint8_t background;		/* fork */
	uint8_t running;
	
} g;

struct noncesync{
	
	uint8_t mountme; 	/* data in here is ready for mount */
	uint8_t gone;		/* drive and/or partition removed */
	uint8_t sync;		/* nonce written */
	uint8_t active; 	/* drive removed after a good sync */
	uint8_t *nonce; /* should hold random bytes */
	
	char partition_device[32];   	/* usable/writable partition like 'sda1' */
	char parent_device[32];			/* this would be the device the partition above lies on,as in 'sda' */
	char partition_devpath[256];  	/* sysfs path  for these last two */
	char parent_devpath[256];
	
	/* libudev handles */
	struct udev *u;
	struct udev_monitor *um;
	struct udev_device *ud;
	struct udev_enumerate *ue;
	struct udev_queue *uq;
	int ufd;
};

struct mcast{
	int sk;
	struct sockaddr_in d;
};

inline int poprand(char *buf,int sz){
	int ret=0;
	FILE *rf;
	do{
		rf=fopen("/dev/urandom","r");
		if(rf==NULL){
			syslog(LOG_CRIT,"Unable to open /dev/urandom %s",strerror(errno));
			return -1;
		}
		
		ret= fread(buf,1,sz,rf);//linker errors on 4.4.8 :( --->getrandom((void *) buf,g.nsz,GRND_RANDOM);
		if(ret==-1){
			syslog(LOG_CRIT,"poprandom error %s",strerror(errno));
			return -1;
		}
		if(ret<g.nsz){
			syslog(LOG_ERR,"Not enough random bytes, trying again...");
		}else{
			return 0;
		}
		usleep(500);	
		fclose(rf);
	}while(ret<g.nsz);
	
	return -1;	
}



static int init_udev(struct noncesync *n){
	n->u=udev_new();
	n->ue=udev_enumerate_new(n->u);
	n->uq=udev_queue_new(n->u);
	
	if(udev_enumerate_add_match_subsystem(n->ue,"block")<0){
		syslog(LOG_CRIT,"udev_enumerate_add_match_subsystem error %s",strerror(errno));
	}
	
	
	if(!n->u){
		syslog(LOG_CRIT,"Error getting a udev handle %s",strerror(errno));
		return -1;
	}
	
	n->um=udev_monitor_new_from_netlink(n->u,"udev");
	if(n->um==NULL){
		syslog(LOG_CRIT,"udev_monitor_new_from_netlink error %s",strerror(errno));
		return -1;
	}
	if(udev_monitor_filter_add_match_subsystem_devtype(n->um,"block",NULL)<0){
		syslog(LOG_CRIT,"udev_monitor_filter_add_match_subsystem_devtype error %s",strerror(errno));
		return -1;
	}
	if(udev_monitor_enable_receiving(n->um)<0){
		syslog(LOG_CRIT,"udev_monitor_enable_receiving error %s",strerror(errno));
		return -1;
	}
	n->ufd=udev_monitor_get_fd(n->um);
	
	/* snprintf(g.devp,12,"%s", udev_get_dev_path(n->u)); <-- would be nice right? 'systemd'-udev removed it :/ */
	snprintf(g.devp,12,"/dev"); 
	
return 0;	
}
void monitor(struct noncesync *n){

	int ret;
	struct pollfd pfd;
	char sysname[32],devpath[256];
	char action[32],removable[10],readonly[10],partition[10];
	
	n->mountme=0;

	pfd.fd=n->ufd;
	
	if(pfd.fd<1){
		syslog(LOG_ERR,"udev_monitor_get_fd error %s",strerror(errno));
		return ;
	}
	
	pfd.events=POLLIN;


	while(!udev_queue_get_queue_is_empty(n->uq)){
		ret=poll(&pfd,1,-1);
		if (ret<0){
			syslog(LOG_ERR,"Poll error %s",strerror(errno));
		}else{
			n->ud=udev_monitor_receive_device(n->um);
			if(n->ud==NULL){
				syslog(LOG_ERR,"udev_monitor_receive_device error. %s",strerror(errno));
				return;
			}
			
			
			
			snprintf(sysname,32,"%s",udev_device_get_sysname(n->ud));
			snprintf(devpath,255,"%s",udev_device_get_devpath(n->ud));
			snprintf(action,30,"%s",udev_device_get_action(n->ud));
			snprintf(removable,5,"%s",udev_device_get_sysattr_value(n->ud,"removable"));
			snprintf(readonly,5,"%s",udev_device_get_sysattr_value(n->ud,"ro"));
			snprintf(partition,5,"%s",udev_device_get_sysattr_value(n->ud,"partition"));
			
			if(strncmp(action,"add",3)==0 &&  strncmp(partition,"1",1)!=0 && strncmp(removable,"1",1)==0 && strncmp(readonly,"0",1)==0){ //parent block , like /dev/sda
					syslog(LOG_INFO,"---------------------------------\n");
					syslog(LOG_NOTICE,"New removable drive added on %s/%s\n",g.devp,sysname);
					syslog(LOG_INFO,"Dev path: %s\n",devpath);
					syslog(LOG_INFO,"Action: %s\n",action);
					syslog(LOG_INFO,"Readonly: %s\n",readonly);
					syslog(LOG_INFO,"Removable: %s\n",removable);
					
					snprintf(n->parent_device,32,"%s",sysname);
					snprintf(n->parent_devpath,256,"%s",devpath);		
					n->gone=0;
					return;
			}else if(strncmp(action,"add",3)==0  && strncmp("1",partition,1)==0 ){ //child partition like /dev/sda1
				struct udev_device *parent=udev_device_get_parent(n->ud);
				
				if (parent==NULL)return;
				udev_enumerate_scan_devices(n->ue);
				if(strncmp(n->parent_devpath,udev_device_get_devpath(parent),32)==0){
					syslog(LOG_INFO,"---------------------------------\n");
					syslog(LOG_NOTICE,"New partition added on %s/%s\n",g.devp,sysname);
					syslog(LOG_INFO,"Dev path: %s\n",devpath);
					syslog(LOG_INFO,"Action: %s\n",action);
					syslog(LOG_INFO,"Readonly: %s\n",readonly);
					syslog(LOG_INFO,"Partition: %s\n",partition);
					syslog(LOG_INFO,"Parent device: %s/%s\n",g.devp,udev_device_get_sysname(parent));
					snprintf(n->partition_device,32,"%s",sysname);
					snprintf(n->partition_devpath,256,"%s",devpath);
					n->mountme=1;
					n->gone=0;
					return;
				}	
	
			}else if(strncmp(action,"remove",6)==0){
				udev_enumerate_scan_devices(n->ue);
				syslog(LOG_NOTICE,"removed %s\n",sysname);
				struct udev_device *parent=udev_device_get_parent(n->ud);
				if((!n->gone )&& ((strncmp(udev_device_get_sysname(parent),n->parent_device,32)==0 && strncmp(udev_device_get_devpath(parent),n->parent_devpath,255)==0 ) ||
									(strncmp(sysname,n->partition_device,32)==0 && strncmp(devpath,n->partition_devpath,255)==0 ) ||
									(strncmp(sysname,n->parent_device,32)==0 && strncmp(devpath,n->parent_devpath,255)==0 )
									)){
					syslog(LOG_INFO,"---------------------------------\n");
					syslog(LOG_NOTICE,"Previously detected device removed %s/%s\n",g.devp,sysname);
					syslog(LOG_INFO,"Parent device: %s/%s\n",g.devp,n->parent_device);
					syslog(LOG_INFO,"Parent device path: %s\n",n->parent_devpath);
					syslog(LOG_INFO,"Partition device: %s/%s\n",g.devp,n->partition_device);
					syslog(LOG_INFO,"Partition device path: %s\n",n->parent_devpath);
					syslog(LOG_INFO,"Action: %s\n",action);
					n->gone=1;
					n->mountme=0;
					return;
			}else{
					
					syslog(LOG_INFO,"---------------------------------\n");
					syslog(LOG_INFO,"[%i] Uncaught device removal:/dev/%s ,parent %s,child\n",n->gone,sysname,udev_device_get_sysnum(parent));
					syslog(LOG_INFO,"device removed %s/%s\n",g.devp,sysname);
					syslog(LOG_INFO,"device removed path %s\n",devpath);
					syslog(LOG_INFO,"Action: %s\n",action);
					syslog(LOG_INFO,"In sync for active device:%s/%s\n",g.devp,n->parent_device);
					syslog(LOG_INFO,"In sync for partition:%s/%s\n",g.devp,n->partition_device);
			}
			}
		}
	}
}

static int multicast(const char*buf,int sz,struct mcast* mc){
	int ret;
	if(sz>256)
		sz=256;
	if(sz<0)
		sz=0;
		
	uint8_t sendbuf[256];
	memset(sendbuf,0,256);
	memcpy(sendbuf,buf,sz);
	ret=sendto(mc->sk,sendbuf,sz,0,(struct sockaddr *) &mc->d, sizeof(struct sockaddr_in));
	if(ret <0){
		syslog(LOG_ERR,"sendto error %s",strerror(errno));
		return -1;
	}else{
		return ret;
	}
	return -1;
}

static void init_seccomp () {
     int ret = 0;
     /*if( setgid (65533) ||setuid (65534) ){  :( mount(2) won't work if I do this.
		perror("Failure to drop priviledge using setgid/setuid\r\n");
		exit(1);
		}*/
		
     scmp_filter_ctx ctx;
     ctx = seccomp_init (SCMP_ACT_ALLOW);

	ret += seccomp_rule_add (ctx, SCMP_ACT_ALLOW, SCMP_SYS (arch_prctl), 0);
	ret += seccomp_rule_add (ctx, SCMP_ACT_ALLOW, SCMP_SYS (bind), 0);
	ret += seccomp_rule_add (ctx, SCMP_ACT_ALLOW, SCMP_SYS (brk), 0);
	ret += seccomp_rule_add (ctx, SCMP_ACT_ALLOW, SCMP_SYS (close), 0);
	ret += seccomp_rule_add (ctx, SCMP_ACT_ALLOW, SCMP_SYS (execve), 0);
	ret += seccomp_rule_add (ctx, SCMP_ACT_ALLOW, SCMP_SYS (fstat), 0);
	ret += seccomp_rule_add (ctx, SCMP_ACT_ALLOW, SCMP_SYS (getdents), 0);
	ret += seccomp_rule_add (ctx, SCMP_ACT_ALLOW, SCMP_SYS (getrandom), 0);
	ret += seccomp_rule_add (ctx, SCMP_ACT_ALLOW, SCMP_SYS (getrlimit), 0);
	ret += seccomp_rule_add (ctx, SCMP_ACT_ALLOW, SCMP_SYS (getsockname), 0);
	ret += seccomp_rule_add (ctx, SCMP_ACT_ALLOW, SCMP_SYS (gettid), 0);
	ret += seccomp_rule_add (ctx, SCMP_ACT_ALLOW, SCMP_SYS (lseek), 0);
	ret += seccomp_rule_add (ctx, SCMP_ACT_ALLOW, SCMP_SYS (lstat), 0);
	ret += seccomp_rule_add (ctx, SCMP_ACT_ALLOW, SCMP_SYS (mkdir), 0);
	ret += seccomp_rule_add (ctx, SCMP_ACT_ALLOW, SCMP_SYS (mmap), 0);
	ret += seccomp_rule_add (ctx, SCMP_ACT_ALLOW, SCMP_SYS (mount), 0);
	ret += seccomp_rule_add (ctx, SCMP_ACT_ALLOW, SCMP_SYS (mprotect), 0);
	ret += seccomp_rule_add (ctx, SCMP_ACT_ALLOW, SCMP_SYS (munmap), 0);
	ret += seccomp_rule_add (ctx, SCMP_ACT_ALLOW, SCMP_SYS (open), 0);
	ret += seccomp_rule_add (ctx, SCMP_ACT_ALLOW, SCMP_SYS (poll), 0);
	ret += seccomp_rule_add (ctx, SCMP_ACT_ALLOW, SCMP_SYS (read), 0);
	ret += seccomp_rule_add (ctx, SCMP_ACT_ALLOW, SCMP_SYS (readlinkat), 0);
	ret += seccomp_rule_add (ctx, SCMP_ACT_ALLOW, SCMP_SYS (recvmsg), 0);
	ret += seccomp_rule_add (ctx, SCMP_ACT_ALLOW, SCMP_SYS (rt_sigaction), 0);
	ret += seccomp_rule_add (ctx, SCMP_ACT_ALLOW, SCMP_SYS (rt_sigprocmask), 0);
	ret += seccomp_rule_add (ctx, SCMP_ACT_ALLOW, SCMP_SYS (sendto), 0);
	ret += seccomp_rule_add (ctx, SCMP_ACT_ALLOW, SCMP_SYS (set_robust_list), 0);
	ret += seccomp_rule_add (ctx, SCMP_ACT_ALLOW, SCMP_SYS (set_tid_address), 0);
	ret += seccomp_rule_add (ctx, SCMP_ACT_ALLOW, SCMP_SYS (setsockopt), 0);
	ret += seccomp_rule_add (ctx, SCMP_ACT_ALLOW, SCMP_SYS (socket), 0);
	ret += seccomp_rule_add (ctx, SCMP_ACT_ALLOW, SCMP_SYS (umount2), 0);
	ret += seccomp_rule_add (ctx, SCMP_ACT_ALLOW, SCMP_SYS (write), 0);
	ret += seccomp_rule_add (ctx, SCMP_ACT_ALLOW, SCMP_SYS (ioctl), 1, SCMP_A1 (SCMP_CMP_EQ, (int) TCGETS));
	
	ret += seccomp_rule_add (ctx, SCMP_ACT_ALLOW, SCMP_SYS (seccomp), 0);
     ret = seccomp_load (ctx);
     if (ret < 0){
          syslog(LOG_ALERT,"Error loading SECCOMP!");
          _exit(1);
	  }
     seccomp_release (ctx);

}
void signals (int signal) {

     switch (signal) {
     case SIGSEGV:
          syslog(LOG_ALERT,"CAUGHT A SEGMENTATION FAULT");

          break;
     case SIGKILL:
          syslog(LOG_CRIT,"SIGKILL CAUGHT,EXITING");
          break;

     case SIGTERM:
          syslog(LOG_NOTICE,"SIGTERM received. proceeding with normal termination.");
          g.running=0;
          break;
     case SIGTTOU:
     case SIGPROF:
          syslog(LOG_INFO,"Profiling has started");
          break;
     case 33:
          break;
     default:
          syslog(LOG_CRIT,"Uncaught signal!");
          return;
          break;
     }
}

void usage(){
		 printf("%s Usage:\n"
				"\tusbnonce [-mfdph]\n"
				"\t-m <mountpoint>\t set the filesystem mount point that will be used to temporarily mount the removable drive.\n"
				"\t-f <filesystem>\t set the filesystem the removable drive is expected to use.\n"
				"\t-F \t Don't fork,run as a foreground process.\n"
				"\t-d <ipv4addr>\t set the destination IPv4 address for UDP notifications\n"
				"\t-p <port>\t set the destination port number for UDP notifications.\n"
				"\t-h \t Display this usage info.\n"
				,g.version);
				_exit(1);
}
static int event_loop(){
	
	struct noncesync n;
	struct mcast mc;
	char nonce[g.nsz];

	memset(&n,0,sizeof(n));
	memset(&mc,0,sizeof(struct mcast));
	n.nonce=alloca(g.nsz);
	/* initialize udev handler */ 
	if(init_udev(&n)!=0){
		syslog(LOG_CRIT,"Udev init error!");
		return 1;
		
	}
	
	mc.d.sin_family=AF_INET;
	htonl(inet_aton(g.multicast_addr,&mc.d.sin_addr));
	mc.d.sin_port=htons(g.port);
	
	mc.sk=socket(AF_INET,SOCK_DGRAM,IPPROTO_UDP);
	if(mc.sk<1){
		syslog(LOG_ERR,"Socket creation error,exiting %s ",strerror(errno));
		return -1;
		}
		
	multicast(g.NOTREADY,strlen(g.NOTREADY),&mc);
	syslog(LOG_NOTICE,"Socket init done");
							
	while(g.running){
		usleep(100);
		monitor(&n);
		if(n.mountme){
			char pdev[256];
			snprintf(pdev,255,"%s/%s",g.devp,n.partition_device);
			if(mkdir(g.mountpath,0644)!=0 && errno!=EEXIST){
				syslog(LOG_WARNING,"Warning,mkdir error,mount might fail %s ",strerror(errno));
			}
			if((mount(pdev,g.mountpath,g.fstype,MS_MGC_VAL,NULL))!=0){
				syslog(LOG_ERR,"Mount params: %s %s %s ...\n",pdev,g.mountpath,g.fstype);
				syslog(LOG_ERR,"Error mounting the newly detected device %s ",strerror(errno));
				continue;
			}else{
				syslog(LOG_NOTICE,"Mount successful %s ---> %s\n",pdev,g.mountpath);
				memset(nonce,0,g.nsz);
				if(poprand(&nonce[0],g.nsz)==0){
					char nfile[256];
					snprintf(nfile,256,"%s/.nonce",g.mountpath);
					FILE *nf=fopen(nfile,"rw+");
					if(nf==NULL){
						syslog(LOG_ERR,"Error opening nonce file %s ",strerror(errno));
						syslog(LOG_ERR,"File:%s\n",nfile);
						if(n.sync && n.active){
							syslog(LOG_ERR,"UNLOCKFAIL ");
							multicast(g.UNLOCKFAIL,strlen(g.UNLOCKFAIL),&mc);
						
					}
					umount(g.mountpath);
						continue;
					}else if(!n.sync){
						if(fwrite(nonce,1,g.nsz,nf)!=g.nsz){
							perror("Error writing out nonce");
							fclose(nf);
							umount(g.mountpath);
							continue;
					}else{
						memset(n.nonce,0,g.nsz);
						memcpy(n.nonce,nonce,g.nsz);
						n.sync=1;
						syslog(LOG_ERR,"Nonce written,synced.");
						multicast(g.LOCKREADY,strlen(g.LOCKREADY),&mc);
						fflush(nf);
						fclose(nf);
						umount(g.mountpath);
					}
					
				}else if(n.sync==1){
					int ret=fread(nonce,1,g.nsz,nf);
					if( ret!= g.nsz && n.active){
						syslog(LOG_INFO,"error reading nonce from usb, True negative!");
						syslog(LOG_ERR,"nonce read %i bytes %s",ret,strerror(errno));
						
						multicast(g.UNLOCKFAIL,strlen(g.UNLOCKFAIL),&mc);
						
						fclose(nf);
						umount(g.mountpath);
						
						continue;
					}else{
						if(memcmp(nonce,n.nonce,g.nsz)==0){ // This is where we authenticate,no other logic should result in a True positive(successful authentication).
							syslog(LOG_NOTICE,"True positive,unlock!\n");
							
							multicast(g.UNLOCKREADY,strlen(g.UNLOCKREADY),&mc);
							n.active=0;
							n.sync=0;
							memset(n.nonce,0,g.nsz);
							memset(nonce,0,g.nsz);
							if(fseek(nf,0,SEEK_SET)!=0){
								syslog(LOG_WARNING,"Warning! fseek on nonce failed post successful authentication,next nonce might fail.");
							}
							if(poprand(&nonce[0],g.nsz)==0){
								if(fwrite(nonce,1,g.nsz,nf)!=g.nsz){
									syslog(LOG_ERR,"Error writing out nonce at post successful authentication. %s",strerror(errno));
									umount(g.mountpath);
									fclose(nf);
									continue;
								}else{
									memcpy(n.nonce,nonce,g.nsz);
									n.sync=1;
									syslog(LOG_INFO,"Nonce written,nonce synced\n");
									multicast(g.LOCKREADY,strlen(g.LOCKREADY),&mc);
									fflush(nf);
									fclose(nf);
								}	
							}else{
								syslog(LOG_CRIT,"RNG error post successful authentication.\n");
								}
						}else{
							syslog(LOG_ALERT,"True negative!\n");
							multicast(g.UNLOCKFAIL,strlen(g.UNLOCKFAIL),&mc);
						}
					}
					
					
				}
			}else{
				syslog(LOG_CRIT,"RNG error.\n");
				umount(g.mountpath);
				continue;
				}
			umount(g.mountpath);
			}
		}else if(n.gone){
			
		if(n.sync && !(n.active)){
			syslog(LOG_NOTICE,"LOCK\n");
			n.active=1;
			multicast(g.LOCK,strlen(g.LOCK),&mc);
				}
		}	
	}
	close(mc.sk);	
	return 0;
}

int main(int argc,char **argv){
	
	int c=0;
	
	/*setup shared variables/globals..*/
	g.version="USBnonce 0.1a";
	g.mountpath="/tmp/usbnonce";
	g.fstype="ext4";		
	g.multicast_addr="127.0.0.1";
	g.port=56789; 
	
	g.NOTREADY="NOTREADY";	
	g.LOCKREADY="READYLOCK"; 	
	g.UNLOCKREADY="UNLOCKREADY";	
	g.UNLOCKFAIL="FAILUNLOCK"; 
	g.LOCK="LOCK";
	g.nsz=512; /*512 random bytes for nonce */
	g.background=1;
	
	openlog("USBNONCE",LOG_CONS|LOG_NDELAY|LOG_PERROR|LOG_PID|LOG_NOWAIT,LOG_AUTH);
	/* this was used to prevent buffered terminal output,not needed now but keeping it anyway*/
	setvbuf(stdout,NULL,_IONBF,0);
	
	while((c=getopt(argc,argv,"m:f:d:p:Fh"))!=-1){
			switch(c){
				case 'm':
					g.mountpath=optarg;
					break;
				case 'f':
					g.fstype=optarg;
					break;
				case 'd':
					g.multicast_addr=optarg;
					break;
				case 'p':
					g.port=atoi(optarg);
					break;
				case 'F':
					g.background=0;
					break;
				case 'h':
				default:
					usage();
				}
	}
	
	if(g.background && !fork()){
		/* setup a signal handler */
		for (c = 0; c < 32; c++)
			signal (c, signals);
		/* Initialize seccomp */      
		init_seccomp();
		g.running=1;
		/* main event loop,should  run until g.running==0 */
		event_loop();
		closelog();
	}else if(!g.background){
		/* setup a signal handler */
		for (c = 0; c < 32; c++)
			signal (c, signals);
		/* Initialize seccomp */      
		init_seccomp();
		g.running=1;
		/* main event loop,should  run until g.running==0 */
		event_loop();
		closelog();
		
	}

return 0;
}

